name: Deploy Static Site

on:
    push:
        branches: ['main']
    schedule:
        # Run CloudFront verification daily at 6 AM UTC
        - cron: '0 6 * * *'
    workflow_dispatch:
        # Allow manual trigger for verification

concurrency:
    group: prod-deploy
    cancel-in-progress: true

jobs:
    deploy:
        if: github.event_name == 'push' # All comments in code strictly in English
        runs-on: ubuntu-latest
        permissions:
            id-token: write
            contents: read
        outputs:
            build-id: ${{ steps.build.outputs.build-id }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Use Node 22
              uses: actions/setup-node@v4
              with:
                  node-version: '22'

            - name: Configure AWS
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
                  aws-region: ap-southeast-1

            - name: Set env
              run: |
                  echo "CLOUDFRONT_DISTRIBUTION_ID=E1KNCYS7QKEZ5Q" >> $GITHUB_ENV
                  echo "S3_BUCKET=s3://lexrag-site" >> $GITHUB_ENV
                  echo "CLOUDFRONT_DOMAIN=d26ppb9osin3vx.cloudfront.net" >> $GITHUB_ENV
                  echo "NEXT_PUBLIC_BASE_URL=https://d26ppb9osin3vx.cloudfront.net" >> $GITHUB_ENV
                  echo "NEXT_PUBLIC_BASE_PATH=" >> $GITHUB_ENV
                  echo "NEXT_PUBLIC_APP_URL=https://app.lexrag.com" >> $GITHUB_ENV
                  echo "NEXT_PUBLIC_SEGMENT_ENABLED=true" >> $GITHUB_ENV
                  echo "NEXT_PUBLIC_SEGMENT_DEBUG=false" >> $GITHUB_ENV
                  echo "NODE_ENV=production" >> $GITHUB_ENV

            - name: Build
              id: build
              env:
                  NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
                  NEXT_PUBLIC_BASE_URL: ${{ env.NEXT_PUBLIC_BASE_URL }}
                  NEXT_PUBLIC_BASE_PATH: ${{ env.NEXT_PUBLIC_BASE_PATH }}
                  NEXT_PUBLIC_SEGMENT_ENABLED: ${{ env.NEXT_PUBLIC_SEGMENT_ENABLED }}
                  NEXT_PUBLIC_SEGMENT_WRITE_KEY: ${{ secrets.NEXT_PUBLIC_SEGMENT_WRITE_KEY }}
                  NEXT_PUBLIC_SEGMENT_DEBUG: ${{ env.NEXT_PUBLIC_SEGMENT_DEBUG }}
                  NODE_ENV: ${{ env.NODE_ENV }}
              run: |
                  npm ci
                  npm run build
                  # Extract build ID for smoke tests
                  if [ -f ".next/BUILD_ID" ]; then
                    echo "build-id=$(cat .next/BUILD_ID)" >> $GITHUB_OUTPUT
                  else
                    echo "build-id=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
                  fi

            - name: Deploy
              env:
                  DISTRIBUTION_ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
                  S3_BUCKET: ${{ env.S3_BUCKET }}
                  NEXT_PUBLIC_APP_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
                  NEXT_PUBLIC_BASE_URL: ${{ env.NEXT_PUBLIC_BASE_URL }}
                  NEXT_PUBLIC_BASE_PATH: ${{ env.NEXT_PUBLIC_BASE_PATH }}
                  NEXT_PUBLIC_SEGMENT_ENABLED: ${{ env.NEXT_PUBLIC_SEGMENT_ENABLED }}
                  NEXT_PUBLIC_SEGMENT_WRITE_KEY: ${{ secrets.NEXT_PUBLIC_SEGMENT_WRITE_KEY }}
                  NEXT_PUBLIC_SEGMENT_DEBUG: ${{ env.NEXT_PUBLIC_SEGMENT_DEBUG }}
                  NODE_ENV: ${{ env.NODE_ENV }}
              run: |
                  chmod +x scripts/deploy.sh
                  ./scripts/deploy.sh

            - name: Wait for CloudFront propagation
              run: |
                  echo "Waiting for CloudFront changes to propagate..."
                  # Retry mechanism with exponential backoff
                  for i in {1..5}; do
                    echo "Attempt $i/5: Waiting 30 seconds..."
                    sleep 30
                    
                    # Try to check if headers are propagated
                    if curl -s -I "https://${{ env.CLOUDFRONT_DOMAIN }}/" | grep -q "Content-Security-Policy"; then
                      echo "‚úÖ Headers detected, proceeding with smoke tests..."
                      break
                    fi
                    
                    if [ $i -eq 5 ]; then
                      echo "‚ö†Ô∏è  Headers not detected after 5 attempts, proceeding anyway..."
                    fi
                  done

            - name: Smoke Tests
              env:
                  CLOUDFRONT_DOMAIN: ${{ env.CLOUDFRONT_DOMAIN }}
                  BUILD_ID: ${{ steps.build.outputs.build-id }}
              run: |
                  echo "üß™ Running smoke tests..."
                  echo "Build ID: $BUILD_ID"
                  echo "Domain: $CLOUDFRONT_DOMAIN"

                  # Test 1: HTML headers (should be no-store)
                  echo "Testing HTML headers..."
                  HTML_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "https://$CLOUDFRONT_DOMAIN/" | grep -E "(Cache-Control|Content-Security-Policy|Strict-Transport-Security)" || true)
                  echo "HTML Headers: $HTML_HEADERS"

                  if ! echo "$HTML_HEADERS" | grep -q "no-store"; then
                    echo "‚ùå HTML Cache-Control should be 'no-store'"
                    exit 1
                  fi

                  if ! echo "$HTML_HEADERS" | grep -q "Content-Security-Policy"; then
                    echo "‚ùå Content-Security-Policy header missing"
                    exit 1
                  fi

                  echo "‚úÖ HTML headers OK"

                  # Test 2: Static assets (should be immutable) - use real file from build
                  echo "Testing static assets headers..."
                  if ls -1 out/_next/static/chunks/*.js 1> /dev/null 2>&1; then
                    CHUNK=$(ls -1 out/_next/static/chunks/*.js | head -n1 | xargs -n1 basename)
                    echo "Testing chunk: $CHUNK"
                    
                    STATIC_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "https://$CLOUDFRONT_DOMAIN/_next/static/chunks/$CHUNK" | grep -E "(Cache-Control|Content-Type)" || true)
                    echo "Static Headers: $STATIC_HEADERS"
                    
                    if ! echo "$STATIC_HEADERS" | grep -q "immutable"; then
                      echo "‚ùå Static assets Cache-Control should be 'immutable'"
                      exit 1
                    fi
                    
                    if ! echo "$STATIC_HEADERS" | grep -E -q "(text|application)/javascript"; then
                      echo "‚ùå Static JS should have Content-Type: text/javascript or application/javascript"
                      exit 1
                    fi
                    
                    echo "‚úÖ Static assets headers OK"
                  else
                    echo "‚ö†Ô∏è  No JS chunks found, skipping static assets test"
                  fi

                  # Test 3: Data files (should be no-store) - soft check for App Router
                  echo "Testing data files headers..."
                  DATA_URL="https://$CLOUDFRONT_DOMAIN/_next/data/$BUILD_ID/index.json"
                  DATA_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DATA_URL" || true)
                  if [ "$DATA_STATUS" = "200" ]; then
                    DATA_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "$DATA_URL" | grep -E "(Cache-Control)" || true)
                    if ! echo "$DATA_HEADERS" | grep -q "no-store"; then
                      echo "‚ùå Data files Cache-Control should be 'no-store'"
                      exit 1
                    fi
                    echo "‚úÖ Data files headers OK"
                  else
                    echo "‚ÑπÔ∏è  No _next/data JSON detected (status $DATA_STATUS). Skipping data headers test."
                  fi

                  # Test 4: MIME types validation
                  echo "Testing MIME types..."

                  # Test CSS file (if exists)
                  if ls -1 out/_next/static/css/*.css 1> /dev/null 2>&1; then
                    CSS_FILE=$(ls -1 out/_next/static/css/*.css | head -n1 | xargs -n1 basename)
                    CSS_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "https://$CLOUDFRONT_DOMAIN/_next/static/css/$CSS_FILE" | grep -E "(Content-Type)" || true)
                    if ! echo "$CSS_HEADERS" | grep -q "text/css"; then
                      echo "‚ùå CSS should have Content-Type: text/css"
                      exit 1
                    fi
                    echo "‚úÖ CSS MIME type OK"
                  else
                    echo "‚ö†Ô∏è  No CSS files found, skipping CSS MIME type test"
                  fi

                  # Test font file (if exists)
                  if ls -1 out/_next/static/media/*.woff2 1> /dev/null 2>&1; then
                    FONT_FILE=$(ls -1 out/_next/static/media/*.woff2 | head -n1 | xargs -n1 basename)
                    FONT_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "https://$CLOUDFRONT_DOMAIN/_next/static/media/$FONT_FILE" | grep -E "(Content-Type)" || true)
                    if ! echo "$FONT_HEADERS" | grep -q "font/woff2"; then
                      echo "‚ùå WOFF2 should have Content-Type: font/woff2"
                      exit 1
                    fi
                    echo "‚úÖ Font MIME type OK"
                  else
                    echo "‚ö†Ô∏è  No font files found, skipping font MIME type test"
                  fi

                  # Test SVG file (if exists) - additional MIME check
                  if find out -type f -name "*.svg" | head -n1 | grep -q .; then
                    SVG_FILE=$(find out -type f -name "*.svg" | head -n1 | xargs -n1 basename)
                    SVG_PATH=$(find out -type f -name "*.svg" | head -n1 | sed "s#out/##" | xargs -n1 dirname)
                    SVG_HEADERS=$(curl -s --retry 5 --retry-delay 3 --retry-connrefused -I "https://$CLOUDFRONT_DOMAIN/$SVG_PATH/$SVG_FILE" | grep -i "Content-Type" || true)
                    echo "$SVG_HEADERS" | grep -qi "image/svg+xml" || { echo "‚ùå SVG should have Content-Type: image/svg+xml"; exit 1; }
                    echo "‚úÖ SVG MIME type OK"
                  else
                    echo "‚ÑπÔ∏è  No SVG found, skipping"
                  fi

                  echo "üéâ All smoke tests passed!"

    # Smoke tests job (depends on deploy)
    smoke-tests:
        needs: deploy
        runs-on: ubuntu-latest
        if: always()
        steps:
            - name: Check deployment status
              run: |
                  if [ "${{ needs.deploy.result }}" = "success" ]; then
                    echo "‚úÖ Deployment successful, smoke tests passed"
                  else
                    echo "‚ùå Deployment failed or smoke tests failed"
                    exit 1
                  fi

    # CloudFront verification job (runs on schedule or manual trigger)
    verify_cloudfront:
        if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Configure AWS
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
                  aws-region: ap-southeast-1

            - name: Verify CloudFront setup
              env:
                  DISTRIBUTION_ID: ${{ env.CLOUDFRONT_DISTRIBUTION_ID }}
              run: |
                  echo "üîç Verifying CloudFront configuration..."
                  chmod +x scripts/verify-cloudfront-setup.sh
                  ./scripts/verify-cloudfront-setup.sh

                  # Exit with error if verification fails
                  if [ $? -ne 0 ]; then
                    echo "‚ùå CloudFront configuration verification failed"
                    exit 1
                  fi

                  echo "‚úÖ CloudFront configuration verification passed"
